## JS
### 1. es5中的类和es6中中类的区别
*  1: es6中内部定义的所有方法都是不可枚举的 Object.keys(Point.prototype) ---> [], es5中的内部方法可枚举
*  2：es6中类必须通过new来调用，否则会报错，而es5不用new也可执行
*  3: es6中类不存在变量声明提升，es5存在
*  4：es5不允许继承原生构造函数，es6可以
*  es6继承，先创建父类的实例对象this(必须先调用super方法), 再用子类的构造函数修改this
*  es5继承， 先创建子类的实例对象this，再将父类的方法添加到this(Parent.applay(this))
### 2. 普通函数和箭头函数的区别  
* 1. 箭头函数没有自身的prototype属性，不能作为构造函数
* 2. 箭头函数中的this指向函数所在上下文(外层环境this)， 普通函数中的this指向取决于函数的调用位置
* 3. 箭头函数没有arguments,可以用...rest参数来解决这个问题
* 4. 箭头函数不能当做Generator函数,不能使用yield关键字
### 3. es6 模块化与commonJS 模块化的区别
* es6 编译时输出对外接口 异步加载 输出的是值的引用      
* commonJS 运行时输出 同步加载 输出的值的拷贝 存在值的缓存
### 4. script标签async 和 defer的区别
渲染引擎遇到这两个属性会开始下载外部脚本，但不会等待下载，而是继续执行后面的代码
* defer: 脚本下载完成后不影响页面的渲染，会等待页面渲染完成后执行下载好的脚本（渲染完执行），多个defer脚本，按照出现顺序依次加载
* async: 脚本下载完成后会中端页面的渲染，等到脚本执行完成后，继续页面的渲染（下载完执行），多个defer脚本，不能保证加载顺序
### 5. 浏览器渲染机制
### 6. this的指向
this的指向是在执行时确定，
默认情况下 this指向window 严格模式下指向undefined 
隐式绑定： 对象调用函数中this指向调用函数的对象，显示绑定 call apply bind new

绑定优先级 new > 显示绑定 > 隐式绑定 > 默认绑定

### 7. 作用域的理解
### 8. 闭包
### 9. 事件循环
### 10.垃圾回收
### 11. es5继承方式及优缺点
### 12. 输入一个url后，执行了那些步骤
* dns域名解析
* tcp连接（三次握手，四次挥手）
* 发送http请求
* 创建页面
#### 13. new的执行原理
* 生成一个新对象
* 将构造函数中的this指向新对象，并执行构造函数
* 将新对象的__proto__ 指向 函数的prototype
### 14. JSON.parse(JSON.stringify()) 深拷贝的缺点
* 如果json里有 function,undefined，则序列化的结果会把 function,undefined 丢失
* 如果json里有NaN、Infinity和-Infinity，则序列化的结果会变成null
* 如果json里有对象是由构造函数生成的，则序列化的结果会丢弃对象的 constructor
* 如果对象中存在循环引用的情况也无法实现深拷贝
* 如果json里面有时间对象，则序列化结果：时间对象=>字符串的形式
* 如果json里有RegExp、Error对象，则序列化的结果将只得到空对象 RegExp、Error => {}
### 15. javascript基本类型和复杂类型是存储在哪里？
* 基本类型存储在栈中, 基本类型占用空间相对较小，如果基本类型被闭包引用，会转存到内存堆中。执行上下文也保存在栈中，栈空间小，如果栈空间大，所有类型都存储在栈中，会影响上下文切换的效率，进而影响整个程序的执行效率
* 复杂数据类型存储在内存堆中， 引用类型占用空间相对较大。 js不允许直接操作堆内存，通过栈中的引用去堆中寻址

## CSS
### 1. flex布局
flex: 1 1 100px
flex-grow(放大) flex-shrink（缩小） flex-basis（初始值）
### 2. BFC规范
BFC: 块级格式上下文
### 3.盒模型
* css盒模型 = w3c标准盒模型 + IE盒模型
* 标准盒模型： width = content(内容宽度)
* ie 盒模型: width = content + padding + border
## 性能优化
vue 性能优化
* 减少页面布局的计算
* 区分v-if和v-show的使用场景
* 合理的使用计算机属性来对值的变化进行缓存
* 使用Object.freeze()对只需要显示功能的对象进行冻结，不需要vue来劫持数据，减少组件初始化的时间
* 组件销毁时 将自定义事件一起销毁防止内存泄漏
* 资源图片懒加载
* 路由懒加载 
 很多路由的引入的情况下会导致首屏加载时间变长，出现白屏的时间。将不同路由分割成不同的代码块，然后当路由被访问时才加载对应组件
 * 第三方包的按需引入 ，如果直接引入会导致项目体积过大，可以借助babel-plugin-component来实现
 * 使用performance 和lighthourse查看性能瓶颈

* 
## vue和react的区别
* 页面结构：
react写法是jsx，vue淡化了jsx写法，页面结构使用html,js,css

相同点：
- 都是组件化思想，组件化开发
- 都有虚拟DOM，提高渲染速度
- 都有自己的路由系统，独立的状态管理系统

都是数据驱动： vue proxy拦截变化通知变更，渲染时间和计算不可控，当watcher太多时，可能造成性能问题            react setstate手动通知变更。

vue: 偏声明式 上手简单 开发效率高，api多（双向绑定，指令，修饰符，watch, computed）   方法中的this都指向组件实例
react: 偏命令式 开发效率低 api少 灵活 方法中需要绑定this的指向 hooks解决了this的问题

