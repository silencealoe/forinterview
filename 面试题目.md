## JS
### 1. es5中的类和es6中中类的区别
*  1: es6中内部定义的所有方法都是不可枚举的 Object.keys(Point.prototype) ---> [], es5中的内部方法可枚举
*  2：es6中类必须通过new来调用，否则会报错，而es5不用new也可执行
*  3: es6中类不存在变量声明提升，es5存在
*  4：es5不允许继承原生构造函数，es6可以
*  es6继承，先创建父类的实例对象this(必须先调用super方法), 再用子类的构造函数修改this
*  es5继承， 先创建子类的实例对象this，再将父类的方法添加到this(Parent.applay(this))
### 2. 普通函数和箭头函数的区别  
* 1. 箭头函数没有自身的prototype属性，不能作为构造函数
* 2. 箭头函数中的this指向函数所在上下文(外层环境this)， 普通函数中的this指向取决于函数的调用位置
* 3. 箭头函数没有arguments,可以用...rest参数来解决这个问题
* 4. 箭头函数不能当做Generator函数,不能使用yield关键字
### 3. es6 模块化与commonJS 模块化的区别
* es6 
### 4. script标签async 和 defer的区别
渲染引擎遇到这两个属性会开始下载外部脚本，但不会等待下载，而是继续执行后面的代码
* defer: 脚本下载完成后不影响页面的渲染，会等待页面渲染完成后执行下载好的脚本（渲染完执行），多个defer脚本，按照出现顺序依次加载
* async: 脚本下载完成后会中端页面的渲染，等到脚本执行完成后，继续页面的渲染（下载完执行），多个defer脚本，不能保证加载顺序
### 5. 浏览器渲染机制
### 6. this的指向
### 7. 作用域的理解
### 8. 闭包
### 9. 事件循环
### 10.垃圾回收
### 11. es5继承方式及优缺点
### 12. 输入一个url后，执行了那些步骤
* dns域名解析
* tcp连接（三次握手，四次挥手）
* 发送http请求
* 创建页面
#### 13. new的执行原理
* 生成一个新对象
* 将构造函数中的this指向新对象，并执行构造函数
* 将新对象的__proto__ 指向 函数的prototype
### 14. JSON.parse(JSON.stringify()) 深拷贝的缺点
* 如果json里有 function,undefined，则序列化的结果会把 function,undefined 丢失
* 如果json里有NaN、Infinity和-Infinity，则序列化的结果会变成null
* 如果json里有对象是由构造函数生成的，则序列化的结果会丢弃对象的 constructor
* 如果对象中存在循环引用的情况也无法实现深拷贝
* 如果json里面有时间对象，则序列化结果：时间对象=>字符串的形式
* 如果json里有RegExp、Error对象，则序列化的结果将只得到空对象 RegExp、Error => {}

## CSS
### 1. flex布局
### 2. BFC规范
BFC: 块级格式上下文
### 3.盒模型
* css盒模型 = w3c标准盒模型 + IE盒模型
* 标准盒模型： width = content(内容宽度)
* ie 盒模型: width = content + padding + border
## 性能优化
vue 性能优化
* 减少页面布局的计算
* 区分v-if和v-show的使用场景
* 合理的使用计算机属性来对值的变化进行缓存
* 使用Object.freeze()对只需要显示功能的对象进行冻结，不需要vue来劫持数据，减少组件初始化的时间
* 组件销毁时 将自定义事件一起销毁防止内存泄漏
* 资源图片懒加载
* 路由懒加载 
 很多路由的引入的情况下会导致首屏加载时间变长，出现白屏的时间。将不同路由分割成不同的代码块，然后当路由被访问时才加载对应组件
 * 第三方包的按需引入 ，如果直接引入会导致项目体积过大，可以借助babel-plugin-component来实现
 * 使用performance 查看性能瓶颈

// 