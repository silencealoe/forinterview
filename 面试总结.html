<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        // 字节跳动

        // 事件循环说输出 1
        // 手写promise.all 1
        // 封装一个柯里化函数
        // 浏览器渲染机制
        // es6 模块化与commonJS 模块化的区别
        // script标签async 和 defer的区别
        // async await实现原理
        // 实现一个数组扁平化函数
        // 原型链说输出 1
        // css flex: 1 实现原理
        // 用css flex 实现一个两列瀑布布局
        // css实现一个三角形
        // es6 class原理
        // es5继承与es6 继承的区别
        // this的指向 1
        // 实现一个new 1
        // vue2.0 的 diff算法, 与vue3.0的区别
        // vue3.0 与2.x 比较有什么特性
        // 项目主要做了什么性能优化
        // 版本号比较大小（算法题）
        // 总结，项目方面没有准备好，说的不是很完整，算法能力不够，有待多练习


        // 浏览器获取html字符串后是怎么渲染执行
        // div中有文本（图片）这种是怎么在页面上显示的（为什么设置不同的字体就能显示不同的字体）
        // rem的原理（通过计算根元素的字体大小），可以使用vw来替代js的计算
        // echarts的实现原理
        // sass转换为css的原理
        // 怎么判断一个二叉树是平衡二叉树
        // 怎么判断单向链表中有环
        // 跨域后端 cross-origin 配置的原理·
        // tcp与udp区别
        // tcp协议为什么要三次握手（为什么客户端和服务端要确认能发送接收数据）
        // css 中使用transform不会触发浏览器重排的原因
        // 关于第三方包的加载方式
        
        // 总结： html实现原理 css原理 数据结构，网络，算法， 编译原理需要提升


        
// 滴滴
// * css 定位？static relative的区别 .fixed什么时候会失效（ie6 ???）
// * 等比缩放的实现方法(rem vw flex grid 百分比)
// * js简单类型和复杂类型的区别（存储方式 。。。。）
// http强缓存和协商缓存
// 手写节流
// 手写深拷贝
// vue组件通信方式
// vue3.0特性
// jsonp原理

// 百度短视频
// vue响应式原理
// v-model实现原理
// vue路由hash和history区别
// vuex mutations 和 actions
// vue组件通信
// BFC实现
// promise
// flex布局
// 圣杯布局
// 浏览器执行html, css js过程，重绘和重排
// http缓存
// 常用状态码（502 代理服务器问题 504 nginx配置问题）
// let const var
// 基本数据类型 以及判断方式
// BOM 
// 实现一个快速排序
// 请求的处理

// 百度
// 项目跨域怎么携带cookie
// 使用webwork去执行计算量大的js
// servicework 实现缓存
// 线上怎么解决跨域问题,前后端配置同样得地址
// 两数之和 （时间复杂度 O(n)）
// css3为什么性能快，怎么开启gpu加速
// 性能优化？？？？
// forEach跳出循环（forEach中使用return是跳出当前循环执行下一次循环，跳出循环可以使用抛出异常）
// 

// 滴滴二战 
// 手写三角形 v
// 手写loading v
// 手写instanceOf v
// 手写reduce (实现按数组中对象的属性去重)
// 手写对象可迭代
// webpack ****
// vue源码
// nextick
// v-for和v-if 优先级
// key的作用
// diff算法
// 判断数组的方法
// 函数柯里化


// 新浪
// 原型链,构造函数不同返回值
// 图片撑开元素底部有空白
// margin-top重叠问题
// 事件循环说输出
// 实现一个数组flat
// 循环中有异步,(闭包和let来解决)
// 大文件上传解决方案 断点续传


// webpack原理
// babel原理
//  es6 import必须放在最上面的原因
// 括号匹配
// 基本数据类型和引用类型为什么要分别存在栈和堆中
// 路由hash和history的区别
// 浏览器缓存（强缓存中如何向服务器发起请求：修改引用文件名称，webpack等打包工具会在文件名后面加上hash）
// 本地存储webstoragge cookie (cookie session token)

// 自如：
// 深度优先遍历和广度优先遍历
// 节流和防抖
// 从输入url到页面展现
// http2和http1区别
// 堆
// vue3 proxy reflect
// 设计模式
// intersectionObserver 观察者模式
// webpack loader工作原理
// jsbridge

// 云智慧
// 如何设计一个订阅发布模式 react哪个hook用了这个模式usecontext
// 说一下 promise
// async await 
// 字符串去重
// webpack优化
// 浏览器缓存
// 浏览器两个tab如何通信
// react hook 如何避免组件重复渲染
// hooks 和 class的区别，hook有哪些优化点
// 模块化 esmodule commonjs 区别 。
// js为什么设计闭包 、
// 执行上下文 和 作用域, this的指向
// react层面的优化做了哪些
// http2.0和1.0区别， htt2.0多路复用的缺点  http3.0 ？
// usestate为什么不能放在if判断中 单向链表
// meta中设置的缓存和浏览器缓存有什么区别
// 如何实现页面多个主题颜色 css变量 属性选择器
    </script>
</body>
</html>