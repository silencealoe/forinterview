## 场景
支付
登录
## http + TLS
在应用层和传输层之间加了个安全层 处理数据的加密与解密
## 对称加密
在发送数据前 浏览器和服务器协商加密方式和密钥 
对称加密 加密和解密使用的是同一个密钥 
缺点： 密钥容易被黑客截获 进行数据解密


## 非对称加密
服务端保留私钥 将公钥传给客户端
客户端保留自己的私钥 将自己的公钥传给服务端
两对密钥
缺点： 效率不高 攻击者可以获取到公钥对服务端数据进行解密
## 数字证书
## https工作模式
加密套件候选列表： 浏览器和服务器支持的加密方式
各大CA机构的公钥是默认安装在操作系统里的

传递数据使用的是对称加密 对称加密使用的密钥使用非对称加密传输

https双向认证流程：
客户端                      服务端
生成自己的随机数 p            生成自己的随机数 q
交换p 得到 q                  交换q得到p
生成随机私钥a pre-master      生成随机私钥b pre-master
计算出公钥  A=q^a mod p       计算公钥B=q^b mod p
交换公钥 A 得到B（服务器公钥）   交换公钥B 得到A(浏览器公钥) 
计算对称密钥                    K = A ^ b mod p = q ^ ab mod p
K = B^a mod p
= q^ab mod p

计算出的对称密钥一致
## https 解决http中的问题：
* 明文传输 很容易别窃取
* 没有验证对端的身份 容易被伪装
tcp3次握手 -> 验证身份 -> tls连接握手 -> 发送数据

## http版本差异
* http 0.9
发送完一个请求就断开了tcp连接 
没有请求头和响应头，不区分传输的内容类型，因为当时只传输HTML
- 1. 只有一个请求行 没有请求头和请求体
- 2. 服务端也没有响应头信息返回
- 3. 返回的文件内容是以ASCII码传输

* http 1.0
- 支持多种类型文件下载 引入了请求头和响应头
- 1. 浏览器需要知道服务器返回的数据类型 accept: text/html
- 2. 服务端压缩数据的方法： accept-encoding: gzip
- 3. 浏览器告诉服务器提供的语言版本： accept-launage: zh-CN
- 4. 浏览器需要知道文件的编码类型： accept-charset: ISO-8559-1, utf-8
- 新增状态码
- cache缓存
- 请求头加入用户代理字段（统计客户端的基础信息）

* http 1.1
- TCP持久连接 connection: keep-alive  / close
同一个域名默认允许建立6个tcp连接
对头阻塞问题： 后一个http请求需要等待前一个http请求返回才能发送 若某个请求因为某些原因没有及时返回 就会阻塞后面的请求
为了不阻塞多个请求 chrome 允许创建6个tcp连接 最多能够同时发送6个请求
host: 字段表示当前的域名地址
- 引入了cookie 安全机制 多个域名映射同一个ip



* http 2.0
- 多路复用：
将请求分成一帧一帧的数据去传输 多个请求复用同一个tcp连接
请求被转换成一个个带有请求ID编号的帧 通过协议栈将这些帧发送给服务器 服务器将所有id一致的请求合并起来 
- 服务器主动推送： 
- 头部压缩


* http 3.0
使用udp实现 在udp上一层加入一层quic协议 解决tcp的对头阻塞问题
